<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cypress MQTT library: Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="cypress_logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Cypress MQTT library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Overview </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Cypress MQTT library provides an easy-to-use APIs for Cypress devices to connect with cloud MQTT brokers and perform MQTT publish and subscribe operations.</p>
<h1><a class="anchor" id="section1"></a>
Library Components</h1>
<p>This MQTT library consists of two components: 1) AWS IoT Device SDK library 2) Platform porting layer</p>
<p>AWS IoT Device SDK library is an open source library and it uses the platform porting layer functions to perform MQTT operations. Hence, the application that uses this library should invoke the AWS IoT Device SDK library APIs and the platform porting layer APIs to perform MQTT publish/subscribe operations.</p>
<p><b>Library link:</b> <a href="https://github.com/aws/aws-iot-device-sdk-embedded-C/tree/v4_beta">https://github.com/aws/aws-iot-device-sdk-embedded-C/tree/v4_beta</a></p>
<h2><a class="anchor" id="section1_1"></a>
AWS IoT Device SDK C - v4.0.0</h2>
<p>This is an open source MQTT library developed and maintained by Amazon. This library implements the core MQTT protocol logic.</p>
<ul>
<li>"AWS IoT Device SDK C v4.0.0" library provides following features:<ul>
<li>MQTT 3.1.1 client</li>
<li>Asynchronous API for MQTT operations.</li>
<li>Multithreaded API by default.</li>
<li>Complete separation of MQTT and network stack, allowing MQTT to run on top of any network stack.</li>
<li>Configurable memory allocation (static-only or dynamic). Memory allocation functions may also be set by the user.</li>
<li>MQTT persistent session support.</li>
<li>Supports Quality of Service (QoS) levels 0 and 1</li>
<li>Supports MQTT connection over both secured and non secured TCP connections.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="section1_2"></a>
Platform Porting Layer</h2>
<p>This portable layer provides the APIs that are required for 'AWS IoT Device SDK library' to perform OS and Network related operations on the Cypress platform. This layer contains APIs that are used for creating thread, mutex, timers, etc. And it also contains APIs to establish secure/non-secure socket connections with MQTT broker to send and receive MQTT messages.</p>
<h1><a class="anchor" id="section_platforms"></a>
Supported Platforms</h1>
<p>This library and its features are supported on following Cypress platforms:</p><ul>
<li><a href="https://www.cypress.com/documentation/development-kitsboards/psoc-6-wi-fi-bt-prototyping-kit-cy8cproto-062-4343w">PSoC6 WiFi-BT Prototyping Kit (CY8CPROTO-062-4343W)</a></li>
<li><a href="https://www.cypress.com/documentation/development-kitsboards/psoc-62s2-wi-fi-bt-pioneer-kit-cy8ckit-062s2-43012">PSoC 62S2 Wi-Fi BT Pioneer Kit (CY8CKIT-062S2-43012)</a></li>
</ul>
<h1><a class="anchor" id="section_dependencies"></a>
Dependent libraries</h1>
<p>This MQTT client library depends on the following libraries. Both these libraries are included by default.</p><ul>
<li><a href="https://github.com/cypresssemiconductorco/wifi-mw-core">Wi-Fi Middleware Core</a></li>
<li><a href="https://github.com/aws/aws-iot-device-sdk-embedded-C/tree/v4_beta/libraries/standard/mqtt">AWS IoT Device SDK MQTT library</a></li>
</ul>
<h1><a class="anchor" id="section_quick_start"></a>
Quick start</h1>
<ul>
<li>A "reasonable amount of time" to wait for keep-alive responses from the MQTT broker is configured using IOT_MQTT_RESPONSE_WAIT_MS in <a href="./cyport/include/iot_config.h">iot_config.h</a>. This value may be adjusted to suit the use case and network environment.</li>
<li>The reference <a href="./cyport/include/iot_config.h">iot_config.h</a> that is bundled with this library provides the configurations required for <a href="https://github.com/aws/aws-iot-device-sdk-embedded-C/tree/v4_beta/libraries/standard/mqtt">AWS IoT Device SDK</a> library. The application must copy this file to the root directory where the application Makefile is present, and suitably adjust the default settings.</li>
<li>This MQTT client library does not support secure connections to the public test.mosquitto.org broker by default, as the server uses SHA1 hashing algorithm. As cautioned by mbedTLS, SHA-1 is considered a weak message digest and is therefore not enabled by default by mbedTLS. The use of SHA-1 for certificate signing constitutes a security risk. It is recommended to avoid dependencies on it, and consider stronger message digests instead. However, if it is desired to connect securely to test.mosquitto.org, follow these steps to enable support:<ol type="1">
<li>Define the below macro in your application: <div class="fragment"><div class="line">CY_MQTT_ENABLE_SECURE_TEST_MOSQUITTO_SUPPORT  </div></div><!-- fragment --></li>
<li>Enable SHA1 support in mbedTLS by defining the below macro in wifi-mw-core/configs/mbedtls_user_config.h: <div class="fragment"><div class="line"><span class="preprocessor">#define MBEDTLS_TLS_DEFAULT_ALLOW_SHA1_IN_CERTIFICATES  </span></div></div><!-- fragment --></li>
</ol>
</li>
<li>A set of pre-defined configuration files have been bundled with wifi-mw-core library for FreeRTOS, LwIP and MbedTLS. The developer is expected to review the configuration and make adjustments. Refer to the Quick start section in <a href="https://github.com/cypresssemiconductorco/wifi-mw-core/blob/master/README.md">README.md</a> for more details</li>
<li>A set of COMPONENTS have to be defined in the code example project's Makefile for MQTT library. Refer to the Quick start section in <a href="https://github.com/cypresssemiconductorco/wifi-mw-core/blob/master/README.md">README.md</a> for more details</li>
<li>Configure the following macros defined in cyport/include/iot_config.h file to enable/disable debug logs in this library: <div class="fragment"><div class="line"><span class="preprocessor">#define IOT_LOG_LEVEL_GLOBAL                        IOT_LOG_ERROR</span></div><div class="line"><span class="preprocessor">#define IOT_LOG_LEVEL_DEMO                          IOT_LOG_ERROR</span></div><div class="line"><span class="preprocessor">#define IOT_LOG_LEVEL_PLATFORM                      IOT_LOG_ERROR</span></div><div class="line"><span class="preprocessor">#define IOT_LOG_LEVEL_NETWORK                       IOT_LOG_ERROR</span></div><div class="line"><span class="preprocessor">#define IOT_LOG_LEVEL_TASKPOOL                      IOT_LOG_ERROR</span></div><div class="line"><span class="preprocessor">#define IOT_LOG_LEVEL_MQTT                          IOT_LOG_ERROR</span></div><div class="line"><span class="preprocessor">#define AWS_IOT_LOG_LEVEL_SHADOW                    IOT_LOG_ERROR</span></div><div class="line"><span class="preprocessor">#define AWS_IOT_LOG_LEVEL_DEFENDER                  IOT_LOG_ERROR</span></div><div class="line"><span class="preprocessor">#define AWS_IOT_LOG_LEVEL_JOBS                      IOT_LOG_ERROR</span></div></div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="section_code_snippet"></a>
Code Snippets</h1>
<h2><a class="anchor" id="snip1"></a>
Code Snippet 1: Initialize MQTT and dependent libraries</h2>
<p>This code snippet demonstrates the initialization of the various libraries like the AWS IoT device SDK, Cypress secure sockets, and the AWS IoT MQTT. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> snippet_mqtt_init(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Status variables for various operations */</span></div><div class="line">    IotNetworkError_t networkStatus = IOT_NETWORK_SUCCESS;</div><div class="line">    IotMqttError_t mqttStatus = IOT_MQTT_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the AWS IoT device SDK */</span></div><div class="line">    IotSdk_Init();</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the Cypress Secure Sockets library */</span></div><div class="line">    networkStatus = <a class="code" href="group__mqtt__cyport__function.html#ga79702091072df13f4ec2efbc5c083333">IotNetworkSecureSockets_Init</a>();</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the MQTT library */</span></div><div class="line">    mqttStatus = IotMqtt_Init();</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="snip2"></a>
Code Snippet 2: Non Secure connection to MQTT broker</h2>
<p>This code snippet demonstrates the initialization of configuration structures required for a non-secure MQTT connection and the usage of IotMqtt_Connect() API. </p><div class="fragment"><div class="line"><span class="comment">/* MQTT Broker/Server address and port used for the MQTT connection */</span></div><div class="line"><span class="preprocessor">#define MQTT_BROKER_ADDRESS               &quot;&lt;MQTT-BROKER-ADDRESS&gt;&quot;</span></div><div class="line"><span class="preprocessor">#define MQTT_PORT                         1883</span></div><div class="line"></div><div class="line"><span class="comment">/* Every active MQTT connection must have a unique client identifier.</span></div><div class="line"><span class="comment"> * Note: The longest client identifier that an MQTT server must accept (as </span></div><div class="line"><span class="comment"> *       defined by the MQTT 3.1.1 spec) is 23 characters.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="preprocessor">#define MQTT_CLIENT_IDENTIFIER            &quot;psoc6-mqtt-client&quot;</span></div><div class="line"></div><div class="line"><span class="comment">/* The timeout in milliseconds for the MQTT operations */</span></div><div class="line"><span class="preprocessor">#define MQTT_TIMEOUT_MS                   (5000)</span></div><div class="line"></div><div class="line"><span class="comment">/* The keep-alive interval in seconds used for MQTT ping request */</span></div><div class="line"><span class="preprocessor">#define MQTT_KEEP_ALIVE_SECONDS           (60)</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> snippet_mqtt_connection(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Status variable */</span></div><div class="line">    IotMqttError_t result = IOT_MQTT_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* MQTT connection handle */</span></div><div class="line">    IotMqttConnection_t mqttConnection = IOT_MQTT_CONNECTION_INITIALIZER;</div><div class="line"></div><div class="line">    <span class="comment">/* Configuration structure with the MQTT Broker/Server details */</span></div><div class="line">    <span class="keyword">struct </span>IotNetworkServerInfo networkServerInfo =</div><div class="line">    {</div><div class="line">        .pHostName = MQTT_BROKER_ADDRESS,</div><div class="line">        .port = MQTT_PORT</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* Configuration structure with the network interface details */</span></div><div class="line">    IotMqttNetworkInfo_t networkInfo =</div><div class="line">    {</div><div class="line">        .createNetworkConnection = <span class="keyword">true</span>,</div><div class="line">        .u.setup.pNetworkCredentialInfo = NULL,</div><div class="line">        .u.setup.pNetworkServerInfo = &amp;networkServerInfo,</div><div class="line">        .pNetworkInterface = IOT_NETWORK_INTERFACE_CY_SECURE_SOCKETS</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* Configuration structure with the MQTT connection information */</span></div><div class="line">    IotMqttConnectInfo_t connectionInfo =</div><div class="line">    {</div><div class="line">        .cleanSession = <span class="keyword">true</span>,</div><div class="line">        .awsIotMqttMode = <span class="keyword">false</span>,</div><div class="line">        .keepAliveSeconds = MQTT_KEEP_ALIVE_SECONDS,</div><div class="line">        .pClientIdentifier = MQTT_CLIENT_IDENTIFIER,</div><div class="line">        .clientIdentifierLength = strlen(MQTT_CLIENT_IDENTIFIER),</div><div class="line">        .pWillInfo = NULL,</div><div class="line">        .pUserName = NULL,</div><div class="line">        .pPassword = NULL,</div><div class="line">        .userNameLength = 0,</div><div class="line">        .passwordLength = 0</div><div class="line">    };</div><div class="line"></div><div class="line">    result = IotMqtt_Connect(&amp;networkInfo, &amp;connectionInfo, MQTT_TIMEOUT_MS, &amp;mqttConnection);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="snip3"></a>
Code Snippet 3: Secure connection to MQTT broker</h2>
<p>This code snippet demonstrates the initialization of configuration structures required for a secure MQTT connection and the usage of IotMqtt_Connect() API. </p><div class="fragment"><div class="line"><span class="comment">/* MQTT Broker/Server address and port used for the MQTT connection */</span></div><div class="line"><span class="preprocessor">#define MQTT_BROKER_ADDRESS               &quot;&lt;MQTT-BROKER-ADDRESS&gt;&quot;</span></div><div class="line"><span class="preprocessor">#define MQTT_PORT                         8883</span></div><div class="line"></div><div class="line"><span class="comment">/* Every active MQTT connection must have a unique client identifier.</span></div><div class="line"><span class="comment"> * Note: The longest client identifier that an MQTT server must accept (as </span></div><div class="line"><span class="comment"> *       defined by the MQTT 3.1.1 spec) is 23 characters.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="preprocessor">#define MQTT_CLIENT_IDENTIFIER            &quot;psoc6-mqtt-client&quot;</span></div><div class="line"></div><div class="line"><span class="comment">/* Set this macro to &#39;true&#39; if the MQTT Broker being used is hosted by AWS IoT </span></div><div class="line"><span class="comment"> * Core service, else &#39;false&#39;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="preprocessor">#define AWS_IOT_MQTT_MODE                 ( true )</span></div><div class="line"></div><div class="line"><span class="comment">/* The timeout in milliseconds for the MQTT operations */</span></div><div class="line"><span class="preprocessor">#define MQTT_TIMEOUT_MS                   (5000)</span></div><div class="line"></div><div class="line"><span class="comment">/* The keep-alive interval in seconds used for MQTT ping request */</span></div><div class="line"><span class="preprocessor">#define MQTT_KEEP_ALIVE_SECONDS           (60)</span></div><div class="line"></div><div class="line"><span class="comment">/* Configure the below credentials for a secure connection with the MQTT Broker */</span></div><div class="line"><span class="comment">/* PEM-encoded client certificate */</span></div><div class="line"><span class="preprocessor">#define CLIENT_CERTIFICATE      \</span></div><div class="line"><span class="preprocessor">&quot;-----BEGIN CERTIFICATE-----\n&quot; \</span></div><div class="line"><span class="preprocessor">&quot;........base64 data........\n&quot; \</span></div><div class="line"><span class="preprocessor">&quot;-----END CERTIFICATE-----&quot;</span></div><div class="line"></div><div class="line"><span class="comment">/* PEM-encoded client private key */</span></div><div class="line"><span class="preprocessor">#define CLIENT_PRIVATE_KEY          \</span></div><div class="line"><span class="preprocessor">&quot;-----BEGIN RSA PRIVATE KEY-----\n&quot; \</span></div><div class="line"><span class="preprocessor">&quot;..........base64 data..........\n&quot; \</span></div><div class="line"><span class="preprocessor">&quot;-----END RSA PRIVATE KEY-----&quot;</span></div><div class="line"></div><div class="line"><span class="comment">/* PEM-encoded Root CA certificate */</span></div><div class="line"><span class="preprocessor">#define ROOT_CA_CERTIFICATE     \</span></div><div class="line"><span class="preprocessor">&quot;-----BEGIN CERTIFICATE-----\n&quot; \</span></div><div class="line"><span class="preprocessor">&quot;........base64 data........\n&quot; \</span></div><div class="line"><span class="preprocessor">&quot;-----END CERTIFICATE-----&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> snippet_mqtt_secure_connection(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Status variable */</span></div><div class="line">    IotMqttError_t result = IOT_MQTT_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* MQTT connection handle */</span></div><div class="line">    IotMqttConnection_t mqttConnection = IOT_MQTT_CONNECTION_INITIALIZER;</div><div class="line"></div><div class="line">    <span class="comment">/* Configuration structure with the MQTT Broker/Server details */</span></div><div class="line">    <span class="keyword">struct </span>IotNetworkServerInfo networkServerInfo =</div><div class="line">    {</div><div class="line">        .pHostName = MQTT_BROKER_ADDRESS,</div><div class="line">        .port = MQTT_PORT</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* Configuration structue to store the MQTT client credentials */</span></div><div class="line">    <span class="keyword">struct </span>IotNetworkCredentials credentials =</div><div class="line">    {    </div><div class="line">        .pClientCert = (<span class="keyword">const</span> <span class="keywordtype">char</span> *)CLIENT_CERTIFICATE,</div><div class="line">        .clientCertSize = <span class="keyword">sizeof</span>(CLIENT_CERTIFICATE),</div><div class="line">        .pPrivateKey = (<span class="keyword">const</span> <span class="keywordtype">char</span> *)CLIENT_PRIVATE_KEY,</div><div class="line">        .privateKeySize = <span class="keyword">sizeof</span>(CLIENT_PRIVATE_KEY),</div><div class="line">        .pRootCa = (<span class="keyword">const</span> <span class="keywordtype">char</span> *)ROOT_CA_CERTIFICATE,</div><div class="line">        .rootCaSize = <span class="keyword">sizeof</span>(ROOT_CA_CERTIFICATE),</div><div class="line">        .pAlpnProtos = NULL</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* Configuration structure with the network interface details */</span></div><div class="line">    IotMqttNetworkInfo_t networkInfo =</div><div class="line">    {</div><div class="line">        .createNetworkConnection = <span class="keyword">true</span>,</div><div class="line">        .u.setup.pNetworkCredentialInfo = &amp;credentials,</div><div class="line">        .u.setup.pNetworkServerInfo = &amp;networkServerInfo,</div><div class="line">        .pNetworkInterface = IOT_NETWORK_INTERFACE_CY_SECURE_SOCKETS</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* Configuration structure with the MQTT connection information */</span></div><div class="line">    IotMqttConnectInfo_t connectionInfo =</div><div class="line">    {</div><div class="line">        .cleanSession = <span class="keyword">true</span>,</div><div class="line">        .awsIotMqttMode = AWS_IOT_MQTT_MODE,</div><div class="line">        .keepAliveSeconds = MQTT_KEEP_ALIVE_SECONDS,</div><div class="line">        .pClientIdentifier = MQTT_CLIENT_IDENTIFIER,</div><div class="line">        .clientIdentifierLength = strlen(MQTT_CLIENT_IDENTIFIER),</div><div class="line">        .pWillInfo = NULL,</div><div class="line">        .pUserName = NULL,</div><div class="line">        .pPassword = NULL,</div><div class="line">        .userNameLength = 0,</div><div class="line">        .passwordLength = 0</div><div class="line">    };</div><div class="line"></div><div class="line">    result = IotMqtt_Connect(&amp;networkInfo, &amp;connectionInfo, MQTT_TIMEOUT_MS, &amp;mqttConnection);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="snip4"></a>
Code Snippet 4: Operation completion callback</h2>
<p>MQTT operation completion callback function. Checks for valid parameters and unblocks the waiting thread. </p><div class="fragment"><div class="line"><span class="comment">/* The structure used by the MQTT operation callback function common to all the </span></div><div class="line"><span class="comment"> * asynchronous APIs to unblock the waiting thread</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>mqttOperationCompleteParams</div><div class="line">{</div><div class="line">    IotMqttOperationType_t expectedOperation; <span class="comment">/* Expected completed operation */</span></div><div class="line">    SemaphoreHandle_t waitSem;                <span class="comment">/* Used to unblock waiting test thread */</span></div><div class="line">    IotMqttOperation_t operation;             <span class="comment">/* Reference to expected completed operation */</span></div><div class="line">} mqttOperationCompleteParams_t;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> mqttOperationCallback(<span class="keywordtype">void</span> * pArgument, IotMqttCallbackParam_t * pOperation)</div><div class="line">{</div><div class="line">    mqttOperationCompleteParams_t * pParams = (mqttOperationCompleteParams_t *) pArgument;</div><div class="line"></div><div class="line">    <span class="comment">/* If the operation information matches the parameters and the operation was</span></div><div class="line"><span class="comment">     * successful, unblock the waiting thread</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keywordflow">if</span>((pParams-&gt;expectedOperation == pOperation-&gt;u.operation.type) &amp;&amp;</div><div class="line">       (pParams-&gt;operation == pOperation-&gt;u.operation.reference) &amp;&amp;</div><div class="line">       (pOperation-&gt;u.operation.result == IOT_MQTT_SUCCESS))</div><div class="line">    {</div><div class="line">        xSemaphoreGive(pParams-&gt;waitSem);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="snip5"></a>
Code Snippet 5: MQTT message publish</h2>
<p>This code snippet demonstrates the initialization of the publish message information structure and the usage of IotMqtt_PublishAsync() API. </p><div class="fragment"><div class="line"><span class="comment">/* The timeout in milliseconds for the MQTT operations */</span></div><div class="line"><span class="preprocessor">#define MQTT_TIMEOUT_MS                   (5000)</span></div><div class="line"></div><div class="line"><span class="comment">/* The MQTT topic on which the messages will be published */</span></div><div class="line"><span class="preprocessor">#define PUBLISH_MQTT_TOPIC                &quot;myMqttTopic&quot;</span></div><div class="line"></div><div class="line"><span class="comment">/* The MQTT message that will be published on the above mentioned topic */</span></div><div class="line"><span class="preprocessor">#define MQTT_PUBLISH_MESSAGE              &quot;Hello World!&quot;</span></div><div class="line"></div><div class="line"><span class="comment">/* Set the QoS that is associated with the MQTT publish messages.</span></div><div class="line"><span class="comment"> * Valid choices are 0, and 1. The MQTT library currently does not support </span></div><div class="line"><span class="comment"> * QoS 2, and hence should not be used in this macro.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="preprocessor">#define MQTT_MESSAGES_QOS                 ( 1 )</span></div><div class="line"></div><div class="line"><span class="comment">/* The maximum number of times each Publish operation will be retried */</span></div><div class="line"><span class="preprocessor">#define PUBLISH_RETRY_LIMIT               (10)</span></div><div class="line"></div><div class="line"><span class="comment">/* A Publish message is retried if no response is received within this </span></div><div class="line"><span class="comment"> * time (in milliseconds)</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="preprocessor">#define PUBLISH_RETRY_MS                  (1000)</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> snippet_mqtt_publish(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Status variable */</span></div><div class="line">    IotMqttError_t result = IOT_MQTT_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* The callback function and parameter information required to unblock</span></div><div class="line"><span class="comment">     * this thread after the asynchronous Publish operation is complete</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    mqttOperationCompleteParams_t callbackParam = { .expectedOperation = IOT_MQTT_PUBLISH_TO_SERVER };</div><div class="line">    IotMqttCallbackInfo_t callbackInfo =</div><div class="line">    {</div><div class="line">        .function = mqttOperationCallback,</div><div class="line">        .pCallbackContext = &amp;callbackParam</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* Structure to store publish message information */</span></div><div class="line">    IotMqttPublishInfo_t publishInfo =</div><div class="line">    {</div><div class="line">        .qos = MQTT_MESSAGES_QOS,</div><div class="line">        .pTopicName = PUBLISH_MQTT_TOPIC,</div><div class="line">        .topicNameLength = strlen(PUBLISH_MQTT_TOPIC),</div><div class="line">        .retryMs = PUBLISH_RETRY_MS,</div><div class="line">        .retryLimit = PUBLISH_RETRY_LIMIT,</div><div class="line">        .pPayload = MQTT_PUBLISH_MESSAGE,</div><div class="line">        .payloadLength = strlen(MQTT_PUBLISH_MESSAGE)</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* Create a binary semaphore used to block this thread until the callback</span></div><div class="line"><span class="comment">     * &#39;mqttOperationCallback()&#39; gives the semaphore to unblock the thread</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    callbackParam.waitSem = xSemaphoreCreateBinary();</div><div class="line"></div><div class="line">    <span class="comment">/* Publish the MQTT message with the configured parameters */</span></div><div class="line">    result = IotMqtt_PublishAsync(mqttConnection, &amp;publishInfo, 0, &amp;callbackInfo, &amp;(callbackParam.operation));</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for the Publish operation to complete for at most &#39;MQTT_TIMEOUT_MS&#39;</span></div><div class="line"><span class="comment">     * milliseconds</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keywordflow">if</span>(xSemaphoreTake(callbackParam.waitSem, pdMS_TO_TICKS(MQTT_TIMEOUT_MS)) == pdTRUE)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Publish operation successful */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Destroy the waiting semaphore after the Publish operation is executed */</span></div><div class="line">    vSemaphoreDelete(callbackParam.waitSem);   </div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="snip6"></a>
Code Snippet 6: Subscribed message received callback</h2>
<p>Callback to handle incoming MQTT messages from the broker. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> mqttSubscriptionCallback(<span class="keywordtype">void</span> *pCallbackContext, IotMqttCallbackParam_t *pPublishInfo)</div><div class="line">{</div><div class="line">    <span class="comment">/* MQTT message payload received from the broker */</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *receivedMqttMessage = pPublishInfo-&gt;u.message.info.pPayload;</div><div class="line">    <span class="keywordtype">int</span> receivedMqttMessageLength = pPublishInfo-&gt;u.message.info.payloadLength;</div><div class="line"></div><div class="line">    <span class="comment">/* The subscription topic filter that matched the received message */</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *subscriptionTopicFilter = pPublishInfo-&gt;u.message.pTopicFilter;</div><div class="line">    <span class="keywordtype">int</span> subscriptionTopicFilterLength = pPublishInfo-&gt;u.message.topicFilterLength;</div><div class="line"></div><div class="line">    <span class="comment">/* The MQTT topic on which the message was published to the broker */</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *publishedTopicName = pPublishInfo-&gt;u.message.info.pTopicName;</div><div class="line">    <span class="keywordtype">int</span> publishedTopicNameLength = pPublishInfo-&gt;u.message.info.topicNameLength;</div><div class="line"></div><div class="line">    <span class="comment">/* The QoS of the published message */</span></div><div class="line">    IotMqttQos_t publishedMessageQos = pPublishInfo-&gt;u.message.info.qos;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="snip7"></a>
Code Snippet 7: MQTT message subscribe</h2>
<p>This code snippet demonstrates the initialization of the subscription information structure and the usage of IotMqtt_SubscribeAsync() API. </p><div class="fragment"><div class="line"><span class="comment">/* The timeout in milliseconds for the MQTT operations */</span></div><div class="line"><span class="preprocessor">#define MQTT_TIMEOUT_MS                   (5000)</span></div><div class="line"></div><div class="line"><span class="comment">/* The MQTT topic to be subscribed to */</span></div><div class="line"><span class="preprocessor">#define SUBSCRIBE_MQTT_TOPIC              &quot;myMqttTopic&quot;</span></div><div class="line"></div><div class="line"><span class="comment">/* The number of MQTT topics to be subscribed to */</span></div><div class="line"><span class="preprocessor">#define SUBSCRIPTION_COUNT                (1)</span></div><div class="line"></div><div class="line"><span class="comment">/* Set the QoS that is associated with the MQTT subscribe messages.</span></div><div class="line"><span class="comment"> * Valid choices are 0, and 1. The MQTT library currently does not support </span></div><div class="line"><span class="comment"> * QoS 2, and hence should not be used in this macro.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="preprocessor">#define MQTT_MESSAGES_QOS                 ( 1 )</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> snippet_mqtt_subscribe(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Status variable */</span></div><div class="line">    IotMqttError_t result = IOT_MQTT_SUCCESS;</div><div class="line">    </div><div class="line">    <span class="comment">/* The callback function and parameter information required to unblock </span></div><div class="line"><span class="comment">     * this thread after the asynchronous Subscribe operation is complete</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    mqttOperationCompleteParams_t callbackParam = { .expectedOperation = IOT_MQTT_SUBSCRIBE };</div><div class="line">    IotMqttCallbackInfo_t callbackInfo = </div><div class="line">    {</div><div class="line">        .function = mqttOperationCallback,</div><div class="line">        .pCallbackContext = &amp;callbackParam</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* Structure to store subscription information */</span></div><div class="line">    IotMqttSubscription_t subscribeInfo =</div><div class="line">    {</div><div class="line">        .qos = MQTT_MESSAGES_QOS,</div><div class="line">        .pTopicFilter = SUBSCRIBE_MQTT_TOPIC,</div><div class="line">        .topicFilterLength = strlen(SUBSCRIBE_MQTT_TOPIC),</div><div class="line">        .callback.function = mqttSubscriptionCallback</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* Create a binary semaphore used to block this thread until the callback</span></div><div class="line"><span class="comment">     * &#39;mqttOperationCallback()&#39; gives the semaphore to unblock the thread</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    callbackParam.waitSem = xSemaphoreCreateBinary();</div><div class="line"></div><div class="line">    <span class="comment">/* Subscribe with the configured parameters */</span></div><div class="line">    result = IotMqtt_SubscribeAsync(mqttConnection, &amp;subscribeInfo, SUBSCRIPTION_COUNT, 0, &amp;callbackInfo, &amp;(callbackParam.operation));</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for the Subscribe operation to complete for at most &#39;MQTT_TIMEOUT_MS&#39;</span></div><div class="line"><span class="comment">     * milliseconds</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keywordflow">if</span>(xSemaphoreTake(callbackParam.waitSem, pdMS_TO_TICKS(MQTT_TIMEOUT_MS)) == pdTRUE)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Subscribe operation successful */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Destroy the waiting semaphore after the Subscribe operation is executed */</span></div><div class="line">    vSemaphoreDelete(callbackParam.waitSem); </div><div class="line">}</div></div><!-- fragment --></div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>Cypress MQTT library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
</body>
</html>
